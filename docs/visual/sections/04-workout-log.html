<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KINETIX - Workout Logging Flow</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0A0A0A 0%, #1E1E1E 100%);
            color: #FFFFFF;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 20px;
            line-height: 1.8;
            font-size: 16px;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px;
            background: rgba(157, 78, 221, 0.1);
            border: 2px solid #9D4EDD;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(157, 78, 221, 0.3);
        }
        
        h1 {
            font-size: 3.5em;
            color: #9D4EDD;
            text-shadow: 0 0 20px rgba(157, 78, 221, 0.8);
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #B3B3B3;
            font-size: 1.3em;
            margin-bottom: 30px;
        }
        
        .summary-card, .example-card, .explanation-card {
            margin-bottom: 25px;
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid;
        }
        
        .summary-card {
            background: rgba(157, 78, 221, 0.1);
            border-left-color: #9D4EDD;
        }
        
        .summary-card h3 {
            color: #9D4EDD;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .example-card {
            background: rgba(255, 165, 0, 0.1);
            border-left-color: #FFA500;
        }
        
        .example-card h3 {
            color: #FFA500;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .explanation-card {
            background: rgba(0, 255, 0, 0.1);
            border-left-color: #00FF00;
        }
        
        .explanation-card h3 {
            color: #00FF00;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .summary-card p, .example-card p, .explanation-card p,
        .summary-card ul, .example-card ul, .explanation-card ul {
            color: #E0E0E0;
            font-size: 16px;
            line-height: 1.8;
            margin-bottom: 10px;
        }
        
        .summary-card code, .example-card code, .explanation-card code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            color: #9D4EDD;
            font-family: 'Courier New', monospace;
        }
        
        .diagram-container {
            margin: 30px 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid rgba(157, 78, 221, 0.2);
            overflow-x: auto;
            width: 100%;
        }
        
        .mermaid {
            background: transparent;
            width: 100%;
        }
        
        .version-badge {
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
            margin-left: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .version-badge.v2 {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.25), rgba(0, 200, 0, 0.15));
            color: #00FF00;
            border: 2px solid #00FF00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .version-badge.v3 {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.25), rgba(200, 130, 0, 0.15));
            color: #FFA500;
            border: 2px solid #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
        }
        
        .version-badge.v4 {
            background: linear-gradient(135deg, rgba(0, 191, 255, 0.25), rgba(0, 150, 200, 0.15));
            color: #00BFFF;
            border: 2px solid #00BFFF;
            text-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>KINETIX</h1>
            <p class="subtitle">4. Workout Logging Flow</p>
            
        </header>
        
        <div class="section-content">
<div class="summary-card">
    <h3>📋 Šta je ovo?</h3>
    <p>
        <strong>Workout Logging Flow</strong> pokazuje kako klijent beleži treninge u offline-first režimu.
        Klijent može da loguje treninge čak i bez interneta, a aplikacija će ih sinhronizovati kada se konekcija uspostavi.
    </p>
    <p>
        <strong>Ključni pojmovi:</strong>
    </p>
    <ul>
        <li><code>Isar DB</code> - Lokalna baza podataka na telefonu (offline-first)</li>
        <li><code>isDirty</code> - Flag koji označava da log nije sinhronizovan sa serverom</li>
        <li><code>isSyncing</code> - Lock flag koji sprečava race condition između direktnih API poziva i SyncManager-a</li>
        <li><code>finishWorkout()</code> - Direktan API poziv za logovanje treninga (instant feedback)</li>
        <li><code>markAsMissed()</code> - Direktan API poziv za označavanje propuštenog treninga</li>
        <li><code>SyncManager</code> - Fallback mehanizam za batch sync kada direktni API pozivi ne uspeju (offline scenario)</li>
        <li><code>Cron Job</code> - Automatska analiza nedeljnih treninga (svaki ponedeljak u 23:59)</li>
    </ul>
</div>

<div class="example-card">
    <h3>💡 Primer iz prakse</h3>
    <p>
        <strong>Scenario:</strong> Klijent Petar je u teretani. Završio je trening i želi da zabeleži rezultate.
    </p>
    <p>
        <strong>Šta se dešava (sa internetom):</strong>
    </p>
    <ol>
        <li>Petar unosi podatke (weight, reps, sets, RPE) u aplikaciju</li>
        <li>Petar pritiska "Finish Workout"</li>
        <li>Aplikacija pokušava direktan API poziv (<code>logWorkout</code>) sa retry logikom (1-2 retry-a)</li>
        <li>Server validira da Petar ima aktivan plan, ažurira WorkoutLog i ClientProfile stats</li>
        <li>Aplikacija ažurira lokalnu bazu: <code>isCompleted = true</code>, <code>isDirty = false</code>, <code>isSyncing = false</code></li>
        <li>Petar vidi instant feedback (confetti, success message)</li>
    </ol>
    <p>
        <strong>Šta se dešava (bez interneta):</strong>
    </p>
    <ol>
        <li>Petar pritiska "Finish Workout"</li>
        <li>API poziv ne uspe (network error) nakon retry logike</li>
        <li>Aplikacija čuva podatke lokalno: <code>isCompleted = true</code>, <code>isDirty = true</code> (offline queue)</li>
        <li>Petar vidi poruku: "Workout saved locally. Will sync when online."</li>
        <li>Kada Petar dođe kući i ima internet, SyncManager automatski šalje podatke na server (batch sync)</li>
    </ol>
    <p>
        <strong>Rezultat:</strong> Petar može da trenira i beleži podatke bilo gde, čak i bez interneta. Direktni API pozivi pružaju instant feedback kada je internet dostupan, a SyncManager je fallback za offline scenario.
    </p>
</div>

<div class="mermaid">
sequenceDiagram
    participant Client as Mobile App<br/>(finishWorkout)
    participant IsarDB as Isar (Local DB)
    participant API as Backend API
    participant WorkoutService as WorkoutsService
    participant DB as MongoDB
    participant Sync as SyncManager<br/>(Fallback)
    participant Cron as Cron Job

    Note over Client,IsarDB: OFFLINE-FIRST: Direct API call with fallback
    
    Client->>Client: 1. Migration: dayOfWeek, planId<br/>(if missing)
    Client->>Client: 2. Validation: planId, dayOfWeek<br/>(required fields)
    Client->>IsarDB: 3. Set isSyncing = true<br/>(lock mechanism)
    
    alt Internet available
        Client->>API: 4. POST /api/workouts/log<br/>(direct API call with retry)
        
        API->>WorkoutService: logWorkout(userId, dto)
        
        WorkoutService->>WorkoutService: Validate: Get active plan<br/>for today's date
        
        alt Active plan exists
            WorkoutService->>DB: Find WorkoutLog for today
            DB-->>WorkoutService: WorkoutLog document
            
            WorkoutService->>DB: Update WorkoutLog:<br/>completedExercises, isCompleted: true, completedAt
            DB-->>WorkoutService: Updated log
            
            WorkoutService->>ClientService: Update client stats:<br/>totalWorkoutsCompleted++, currentStreak++
            ClientService->>DB: Update ClientProfile
            
            WorkoutService-->>API: Success (serverId)
            API-->>Client: Success (serverId)
            
            Client->>IsarDB: 5. Update local workout:<br/>isCompleted = true, isDirty = false,<br/>isSyncing = false, serverId
            
            Client->>Client: 6. Show confetti & success message
            Client->>Client: 7. Navigate to /calendar
            
        else No active plan
            WorkoutService-->>API: Error: No active plan
            API-->>Client: Error
            Client->>IsarDB: Mark isDirty = true, isSyncing = false
        end
        
    else No internet (after retries)
        Note over Client: API call failed after retries<br/>(1-2 retries with exponential backoff)
        Client->>IsarDB: Mark isCompleted = true,<br/>isDirty = true, isSyncing = false
        Client->>Client: Show: "Workout saved locally.<br/>Will sync when online."
        
        Note over Sync: Fallback: SyncManager will sync<br/>when internet is available
        Sync->>API: POST /api/sync/batch<br/>(sync dirty workouts)
        API-->>Sync: Success
        Sync->>IsarDB: Mark isDirty = false,<br/>Update serverId
    end
    
    Note over Cron: Every Monday at 23:59
    
    Cron->>WorkoutService: Analyze last week's logs
    
    loop For each client
        WorkoutService->>DB: Count missed workouts (isMissed: true)
        
        alt Missed workouts > 2
            WorkoutService->>ClientService: Enable penalty mode
            WorkoutService->>DB: Add "Penalty Cardio" to next week's plan
            WorkoutService->>DB: Update client.isPenaltyMode = true
            WorkoutService->>DB: Reset client.currentStreak = 0
        else Good adherence
            WorkoutService->>DB: Award badge/achievement
        end
    end

    Note over Client,DB: Result: Direct API call for instant feedback,<br/>SyncManager as fallback for offline scenario
</div>

<div class="summary-card">
    <h3>🎯 finishWorkout() Flow - Detaljni Sequence Diagram</h3>
    <p>
        <strong>Direktan API poziv sa retry logikom, lock mehanizmom i offline fallback-om.</strong>
    </p>
</div>

<div class="mermaid">
sequenceDiagram
    participant User as User
    participant UI as WorkoutStateService<br/>(finishWorkout)
    participant Repo as WorkoutRepository
    participant IsarDB as Isar (Local DB)
    participant API as Backend API<br/>(logWorkout)
    participant Sync as SyncManager<br/>(Fallback)

    User->>UI: Press "Finish Workout"
    
    Note over UI: Step 1: Migration Logic
    alt dayOfWeek is null
        UI->>Repo: migrateDayOfWeek(workout)
        Repo->>IsarDB: Query workout by scheduledDate
        IsarDB-->>Repo: Found workout
        Repo-->>UI: dayOfWeek (1-7)
        UI->>IsarDB: Update workout.dayOfWeek
    end
    
    alt planId is null
        UI->>Repo: migratePlanId(workout)
        Repo->>IsarDB: Query weeklyPlan by date
        IsarDB-->>Repo: Found weeklyPlan
        Repo-->>UI: planId
        UI->>IsarDB: Update workout.planId
    end
    
    Note over UI: Step 2: Validation
    alt planId is null OR dayOfWeek is null
        UI->>User: Show error: "Missing planId/dayOfWeek"
        Note over UI: Cannot proceed without required fields
    end
    
    Note over UI: Step 3: Lock Mechanism
    UI->>IsarDB: Set isSyncing = true<br/>(prevent race condition)
    
    Note over UI: Step 4: Direct API Call with Retry
    UI->>API: POST /api/workouts/log<br/>(timeout: 30s)
    
    alt API Success
        API-->>UI: Success (serverId)
        
        Note over UI: Step 5: Update Local Workout
        UI->>IsarDB: Update workout:<br/>isCompleted = true<br/>isDirty = false<br/>isSyncing = false<br/>serverId = response.serverId
        
        alt Local Update Success
            UI->>User: Show confetti & success message
            UI->>User: Navigate to /calendar
        else Local Update Failed (Partial Success)
            UI->>User: Show warning: "Logged on server,<br/>but local update failed"
            Note over UI: Retry local update with<br/>exponential backoff (2 retries)
        end
        
    else API Failed (Network Error)
        Note over UI: Retry Logic (1-2 retries)<br/>Exponential backoff: 1s, 2s
        
        alt Retry Successful
            API-->>UI: Success (serverId)
            UI->>IsarDB: Update workout (same as above)
        else All Retries Failed
            Note over UI: Offline Detection
            UI->>IsarDB: Update workout:<br/>isCompleted = true<br/>isDirty = true<br/>isSyncing = false
            UI->>User: Show: "Workout saved locally.<br/>Will sync when online."
            UI->>User: Navigate to /calendar
            
            Note over Sync: Fallback: SyncManager
            Sync->>IsarDB: Get dirty workouts (isDirty = true)
            Sync->>API: POST /api/sync/batch<br/>(batch sync)
            API-->>Sync: Success
            Sync->>IsarDB: Mark isDirty = false,<br/>Update serverId
        end
    end
    
    Note over UI,Sync: Result: Instant feedback when online,<br/>offline queue when offline
</div>

<div class="summary-card">
    <h3>⏭️ markAsMissed() Flow - Detaljni Sequence Diagram</h3>
    <p>
        <strong>Direktan API poziv za označavanje propuštenog treninga (samo ako workout ima serverId).</strong>
    </p>
</div>

<div class="mermaid">
sequenceDiagram
    participant User as User
    participant UI as WorkoutStateService<br/>(markAsMissed)
    participant IsarDB as Isar (Local DB)
    participant API as Backend API<br/>(updateWorkoutLog)
    participant Sync as SyncManager<br/>(Fallback)

    User->>UI: Press "Mark as Missed"
    
    Note over UI: Step 1: Lock Check
    alt workout.isSyncing == true
        UI->>User: Show warning: "Workout is already syncing.<br/>Please wait."
        Note over UI: Prevent race condition
    end
    
    Note over UI: Step 2: Check if Workout is Logged
    alt workout.serverId != null
        Note over UI: Workout already logged,<br/>update via API
        
        Note over UI: Step 3: Direct API Call with Retry
        UI->>API: PATCH /api/workouts/log/:serverId<br/>{isMissed: true, isCompleted: false}<br/>(timeout: 30s)
        
        alt API Success
            API-->>UI: Success
            
            Note over UI: Step 4: Update Local Workout
            UI->>IsarDB: Update workout:<br/>isCompleted = false<br/>isMissed = true<br/>isDirty = false<br/>isSyncing = false
            
            alt Local Update Success
                UI->>User: Show: "Workout marked as missed"
                UI->>User: Navigate to /calendar
            else Local Update Failed (Partial Success)
                UI->>User: Show warning: "Marked as missed on server,<br/>but local update failed"
                Note over UI: Retry local update with<br/>exponential backoff (2 retries)
            end
            
        else API Failed (Network Error)
            Note over UI: Retry Logic (1-2 retries)<br/>Exponential backoff: 1s, 2s
            
            alt Retry Successful
                API-->>UI: Success
                UI->>IsarDB: Update workout (same as above)
            else All Retries Failed
                Note over UI: Offline Detection
                UI->>IsarDB: Update workout:<br/>isCompleted = false<br/>isMissed = true<br/>isDirty = true<br/>isSyncing = false
                UI->>User: Show: "Workout marked as missed.<br/>Will sync when online."
                UI->>User: Navigate to /calendar
                
                Note over Sync: Fallback: SyncManager
                Sync->>IsarDB: Get dirty workouts (isDirty = true)
                Sync->>API: POST /api/sync/batch<br/>(batch sync)
                API-->>Sync: Success
                Sync->>IsarDB: Mark isDirty = false
            end
        end
        
    else workout.serverId == null
        Note over UI: Workout not yet logged,<br/>skip API call
        
        UI->>IsarDB: Update workout:<br/>isCompleted = false<br/>isMissed = true<br/>isDirty = true<br/>(will be synced by SyncManager)
        
        UI->>User: Show: "Workout marked as missed.<br/>Will sync when online."
        UI->>User: Navigate to /calendar
        
        Note over Sync: Fallback: SyncManager
        Sync->>IsarDB: Get dirty workouts (isDirty = true)
        Sync->>API: POST /api/sync/batch<br/>(batch sync)
        API-->>Sync: Success
        Sync->>IsarDB: Mark isDirty = false,<br/>Update serverId
    end
    
    Note over UI,Sync: Result: Instant feedback when online,<br/>offline queue when offline
</div>

<div class="explanation-card">
    <h3>🔍 Detaljno objašnjenje</h3>
    <p>
        <strong>Zašto direktni API pozivi umesto SyncManager-a?</strong>
    </p>
    <ul>
        <li><strong>Instant feedback:</strong> Korisnik dobija trenutnu potvrdu da je trening uspešno logovan (confetti, success message)</li>
        <li><strong>Bolje UX:</strong> Ne mora da čeka da SyncManager sinhronizuje podatke u pozadini</li>
        <li><strong>Error handling:</strong> Korisnik vidi greške odmah (npr. "No active plan") umesto da sazna kasnije</li>
    </ul>
    <p>
        <strong>Zašto offline-first?</strong> Teretane često imaju loš WiFi signal. Klijent mora moći da trenira i beleži podatke bez interneta.
    </p>
    <p>
        <strong>Kako radi sinhronizacija:</strong>
    </p>
    <ul>
        <li><strong>Direktni API pozivi:</strong> <code>finishWorkout()</code> i <code>markAsMissed()</code> direktno pozivaju API sa retry logikom (1-2 retry-a sa exponential backoff)</li>
        <li><strong>Lock mehanizam:</strong> <code>isSyncing = true</code> sprečava race condition između direktnih API poziva i SyncManager-a</li>
        <li><strong>Migration logika:</strong> Ako <code>dayOfWeek</code> ili <code>planId</code> nedostaju, pokušava se da se izvuku iz lokalne baze (backward compatibility)</li>
        <li><strong>Offline detection:</strong> Ako API poziv ne uspe nakon retry logike, workout se označava kao <code>isDirty = true</code> za SyncManager</li>
        <li><strong>SyncManager (fallback):</strong> Kada direktni API pozivi ne uspeju (offline scenario), SyncManager automatski sinhronizuje dirty workouts kada se internet uspostavi</li>
        <li><strong>Partial success scenario:</strong> Ako API uspe ali lokalno ažuriranje ne uspe, pokušava se retry lokalnog ažuriranja sa exponential backoff (2 retry-a)</li>
        <li><strong>Timeout handling:</strong> API pozivi imaju timeout od 30 sekundi</li>
    </ul>
    <p>
        <strong>Nedeljna analiza:</strong> Svakog ponedeljka u 23:59, Cron Job analizira prošlu nedelju. Ako je bilo više od 2 propuštena treninga, aktivira se penalty mode i dodaje se "Penalty Cardio" u narednu nedelju.
    </p>
    <p>
        <strong>Razlika između direktnih API poziva i batch sync-a:</strong>
    </p>
    <ul>
        <li><strong>Direktni API pozivi (finishWorkout, markAsMissed):</strong> Koriste se za instant feedback kada je internet dostupan. Koriste <code>logWorkout</code> i <code>updateWorkoutLog</code> API endpoint-e.</li>
        <li><strong>Batch sync (SyncManager):</strong> Koristi se kao fallback mehanizam kada direktni API pozivi ne uspeju (offline scenario). Koristi <code>syncBatch</code> API endpoint za batch sinhronizaciju više workout-a odjednom.</li>
        <li><strong>Lock mehanizam:</strong> SyncManager skip-uje workout-e sa <code>isSyncing = true</code> da spreči race condition.</li>
    </ul>
</div>

        </div>
    </div>
    
    <script>
        let mermaidInitialized = false;
        
        // Initialize Mermaid
        function initMermaid() {
            if (mermaidInitialized) return;
            mermaid.initialize({ 
                startOnLoad: false,
                theme: 'dark',
                themeVariables: {
                    primaryColor: '#9D4EDD',
                    primaryTextColor: '#FFFFFF',
                    primaryBorderColor: '#9D4EDD',
                    lineColor: '#9D4EDD',
                    secondaryColor: '#1E1E1E',
                    tertiaryColor: '#0A0A0A',
                    background: '#1E1E1E',
                    mainBkg: '#1E1E1E',
                    secondBkg: '#0A0A0A',
                    textColor: '#FFFFFF',
                    actorBorder: '#9D4EDD',
                    actorBkg: '#1E1E1E',
                    actorTextColor: '#FFFFFF',
                    actorLineColor: '#9D4EDD',
                    signalColor: '#9D4EDD',
                    signalTextColor: '#FFFFFF',
                    labelBoxBkgColor: '#1E1E1E',
                    labelBoxBorderColor: '#9D4EDD',
                    labelTextColor: '#FFFFFF',
                    loopTextColor: '#FFFFFF',
                    noteBorderColor: '#9D4EDD',
                    noteBkgColor: '#1E1E1E',
                    noteTextColor: '#FFFFFF',
                    activationBorderColor: '#9D4EDD',
                    activationBkgColor: '#1E1E1E',
                    sequenceNumberColor: '#FFFFFF',
                    cScale0: '#9D4EDD',
                    cScale1: '#FF003C',
                    cScale2: '#FFA500'
                },
                flowchart: {
                    curve: 'basis',
                    padding: 40,
                    htmlLabels: true,
                    useMaxWidth: true
                },
                sequence: {
                    diagramMarginX: 80,
                    diagramMarginY: 20,
                    actorMargin: 50,
                    width: 150,
                    height: 65,
                    boxMargin: 10,
                    boxTextMargin: 5,
                    noteMargin: 10,
                    messageMargin: 50,
                    mirrorActors: true,
                    bottomMarginAdj: 1,
                    useMaxWidth: true,
                    rightAngles: false,
                    showSequenceNumbers: false
                },
                er: {
                    fontSize: 14
                }
            });
            mermaidInitialized = true;
        }
        
        // Render all Mermaid diagrams on page load
        window.addEventListener('DOMContentLoaded', () => {
            initMermaid();
            
            setTimeout(() => {
                document.querySelectorAll('.mermaid').forEach(async (element) => {
                    try {
                        const id = 'mermaid-' + Math.random().toString(36).substr(2, 9);
                        element.id = id;
                        await mermaid.run({ nodes: [element] });
                    } catch (error) {
                        console.error('Mermaid rendering error:', error);
                    }
                });
            }, 500);
        });
    </script>
</body>
</html>